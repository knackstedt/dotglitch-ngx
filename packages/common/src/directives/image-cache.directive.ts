import { Directive, ElementRef, Inject, InjectionToken, Input, Optional } from '@angular/core';
import { INDEXEDDB, createInstance } from 'localforage';

const storage = createInstance({
    name: "@dotglitch",
    storeName: "image-cache",
    driver: INDEXEDDB,
    version: 1
});


const imageCache: {
    [key: string]: HTMLImageElement;
} = {};

const loadingSvg = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="32px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><circle cx="50" cy="50" fill="none" stroke="%2340c4ff" stroke-width="10" r="35" stroke-dasharray="164.93361431346415 56.97787143782138"><animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform></circle><!-- [ldio] generated by https://loading.io/ --></svg>`;
const brokenSvg = `data:image/svg+xml;utf8,<svg width="800" height="800" viewBox="0 0 24 24" version="1.1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><line x1="10.08" y1="8.29" x2="10.18" y2="8.29" style="fill:none;stroke:#000000;stroke-width:2.5;stroke-linecap:round;stroke-linejoin:round" /><path d="m 10.51,14.8 5.2,5.2 H 20 a 1,1 0 0 0 1,-1 V 15.73 L 15.29,10 Z M 3,16.71 V 19 a 1,1 0 0 0 1,1 h 11.71 l -8,-8 z M 21,5 v 14 a 1,1 0 0 1 -1,1 H 4 A 1,1 0 0 1 3,19 V 5 A 1,1 0 0 1 4,4 h 16 a 1,1 0 0 1 1,1 z" style="fill:none;stroke:#000000;stroke-width:2;stroke-linecap:round;stroke-linejoin:round" /><path d="M 21.193388,21.193388 2.8066108,2.8066108 m 18.3867772,0 L 2.8066108,21.193388" style="stroke:%23ff0000;stroke-width:2.62668;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1" /></svg>`;

export type NgxImageCacheConfig = {
    /**
     * Image to use as a placeholder while loading the main image
     * Recommended to use inlined SVG or a base64 encoded image
     */
    loadingPlaceholder?: string,
    /**
     * Image to use as a placeholder where images fail to load
     * Recommended to use inlined SVG or a base64 encoded image
     */
    brokenPlaceholder?: string
}

export const NGX_IMAGE_CACHE_CONFIG = new InjectionToken<NgxImageCacheConfig>('ngx-image-cache-config');


export type NgxImageCacheConfiguration = {
    /**
     * Max age to cache an image in milliseconds.
     * If set to `0` or a negative number, images will never expire.
     */
    maxAge: number,
    /**
     * Set to `false` to disable memory caching for the image
     * If both `cacheInMemory` and `cacheInIndexedDB` are false,
     * no caching will happen. (You'll still get the loader)
     */
    cacheInMemory: boolean,
    /**
     * Set to `false` to disable indexedDB caching for the image
     * If both `cacheInMemory` and `cacheInIndexedDB` are false,
     * no caching will happen. (You'll still get the loader)
     */
    cacheInIndexedDB: boolean
}

@Directive({
    selector: 'img[ngx-cache]',
    standalone: true
})
export class NgxImageCacheDirective {

    @Input("source")
    @Input("ngx-cache") url: string;

    @Input("ngx-cache-config") configuration: NgxImageCacheConfiguration;

    private get el() { return this.element.nativeElement as HTMLImageElement }

    constructor(
        private readonly element: ElementRef,
        @Optional() @Inject(NGX_IMAGE_CACHE_CONFIG) private readonly cacheConfig: NgxImageCacheConfig
    ) { }

    ngOnChanges() {
        this.getCachedImage();
    }

    async getCachedImage() {
        if (
            this.el.src?.trim() == this.url?.trim() || // Check that there's an actual change
            this.url?.trim().length == 0 // Check that there's an actual URL
        ) return;

        // Check if it's in the memory cache
        if (imageCache[this.url]) {
            const image = imageCache[this.url];

            // If the image is currently loading, show the loader
            // and add it to the reflist
            if (image['_loading'] == true) {
                image['_refs'].push(this.el);

                this.el.setAttribute("loading", "true");
                this.el.src = this.cacheConfig?.loadingPlaceholder || loadingSvg;
            }
            else {
                // The image is fully loaded, swap out the src with a data-uri
                this.el.setAttribute("loading", "false");
                this.el.src = image.src;
            }

            // If it's already in the image cache, we're going to trust that it loads properly.
            return;
        }

        // Check if it's in indexedDB
        if (this.configuration?.cacheInIndexedDB != false) {
            const cached = await storage.getItem<any>(this.url);
            if (cached) {
                // Attempt to load the base64 data from indexeddb.
                // If this fails, we'll fall back to attempting to download the image
                this.el.src = cached.data;

                const evt: Event = await new Promise(res => {
                    this.el.addEventListener('load', res);
                    this.el.addEventListener('error', res);
                });

                // If the event isn't an error
                if (evt.type == "load") {
                    this.el.setAttribute("loading", "false");

                    if (this.configuration?.cacheInMemory != false) {
                        // Successfully loaded into element
                        // Create an entry in the memory cache
                        const image = imageCache[this.url] = new Image();
                        image.src = cached.data;
                        image['_createdAt'] = Date.now();
                    }
                    return;
                }
                else {
                    // Else, we try to load again.
                    this.el.src = this.cacheConfig?.loadingPlaceholder || loadingSvg;
                }
            }
        }

        const image = (() => {
            if (this.configuration?.cacheInMemory != false) {
                return imageCache[this.url] = new Image();
            }
            return new Image();
        })();

        // const clone = image.cloneNode(true) as HTMLImageElement;
        image['_refs'] = image['_refs'] ?? [];
        image['_refs'].push(this.el);
        image['_loading'] = true;
        image['_createdAt'] = Date.now();

        // Show a loader while the image downloads.
        this.el.setAttribute("loading", "true");
        this.el.src = this.cacheConfig?.loadingPlaceholder || loadingSvg;

        // Fetch the image via JS and cache it as base64
        window.fetch(this.url)
            .then(response => response.blob())
            .then(blob => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    image.src = reader.result as string;

                    storage.setItem(this.url, {
                        timestamp: Date.now(),
                        data: reader.result
                    });

                    image['_refs'].forEach((ref: HTMLImageElement) => {
                        ref.src = image.src;
                    });

                    image['_loading'] = false;
                    resolve(0);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            }))
            .catch(err => {
                // If a failure occurs, purge this entry from the cache
                // TODO: Render better "broken" image
                delete imageCache[this.url];
                image['_refs'].forEach((ref: HTMLImageElement) => {
                    ref.src = this.cacheConfig?.brokenPlaceholder || brokenSvg;
                    ref.setAttribute("loading", "failed");
                });
            });
    }
}
